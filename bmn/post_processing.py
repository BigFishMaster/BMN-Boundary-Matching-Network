# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
import json
import multiprocessing as mp

from bmn.utils import iou_with_anchors


def get_video_data(opt):
    input = open(opt["test_info"], "r").readlines()
    video_data = {}
    for i, item in enumerate(input):
        json_str = item.strip()
        data = json.loads(json_str)
        video_name = data["video_name"]
        video_data[video_name] = data
    return video_data


def soft_nms(df, alpha, t1, t2):
    '''
    df: proposals generated by network;
    alpha: alpha value of Gaussian decaying function;
    t1, t2: threshold for soft nms.
    '''
    df = df.sort_values(by="score", ascending=False)
    tstart = list(df.xmin.values[:])
    tend = list(df.xmax.values[:])
    tscore = list(df.score.values[:])

    rstart = []
    rend = []
    rscore = []

    while len(tscore) > 1 and len(rscore) < 101:
        max_index = tscore.index(max(tscore))
        tmp_iou_list = iou_with_anchors(
            np.array(tstart),
            np.array(tend), tstart[max_index], tend[max_index])
        for idx in range(0, len(tscore)):
            if idx != max_index:
                tmp_iou = tmp_iou_list[idx]
                tmp_width = tend[max_index] - tstart[max_index]
                # TODO: why to use tmp_width?
                if tmp_iou > t1 + (t2 - t1) * tmp_width:
                    tscore[idx] = tscore[idx] * np.exp(-np.square(tmp_iou) /
                                                       alpha)

        rstart.append(tstart[max_index])
        rend.append(tend[max_index])
        rscore.append(tscore[max_index])
        tstart.pop(max_index)
        tend.pop(max_index)
        tscore.pop(max_index)

    newDf = pd.DataFrame()
    newDf['score'] = rscore
    newDf['xmin'] = rstart
    newDf['xmax'] = rend
    return newDf


def video_post_process(opt, result_dict, video_list, video_dict):
    for video_name in video_list:
        df = pd.read_csv(opt["result_dir"] + video_name + ".csv")

        if len(df) > 1:
            snms_alpha = opt["soft_nms_alpha"]
            snms_t1 = opt["soft_nms_low_thres"]
            snms_t2 = opt["soft_nms_high_thres"]
            df = soft_nms(df, snms_alpha, snms_t1, snms_t2)

        df = df.sort_values(by="score", ascending=False)
        video_info = video_dict[video_name]
        feature_frame = video_info["feature_frame"]
        sampled_frame = video_info["sampled_frames"]
        video_seconds = video_info["video_seconds"]
        video_duration = float(feature_frame) / sampled_frame * video_seconds
        proposal_list = []

        for j in range(min(opt["num_proposals"], len(df))):
            tmp_proposal = {"score": df.score.values[j],
                            "segment": [max(0, df.xmin.values[j]) * video_duration,
                                        min(1, df.xmax.values[j]) * video_duration]}
            proposal_list.append(tmp_proposal)
        video_name = video_name.split(".mp4")[0]
        result_dict[video_name] = proposal_list


def BMN_post_processing(opt):
    video_data = get_video_data(opt)
    video_list = list(video_data.keys())
    result_dict = mp.Manager().dict()

    num = len(video_list)
    # real number are threads + 1
    threads = opt["post_process_thread"]
    num_per_thread = num // threads
    processes = []
    for t in range(threads):
        start = t * num_per_thread
        end = min((t + 1) * num_per_thread, num)
        v = video_list[start:end]
        p = mp.Process(target=video_post_process, args=(opt, result_dict, v, video_data))
        p.start()
        processes.append(p)

    for p in processes:
        p.join()

    result_dict = dict(result_dict)
    fout = open(opt["result_file"], "w")
    json.dump(result_dict, fout)
    fout.close()
